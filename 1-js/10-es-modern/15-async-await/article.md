# Async/await

Для более комфортной работы с промисами существует специальный синтаксис — "async/await". Он удивительно прост в понимании и использовании.

## Асинхронные функции

Начнём с ключевого слова `async`. Его можно написать перед функцией, вот так:

```js
async function f() {
  return 1;
}
```

Слово "async" перед функцией говорит о следующем: данная функция всегда возвращает промис. Если в коде есть `return <не-промис>`, то JavaScript автоматически завернёт возвращаемое значение в промис, разрешающийся этим значением.

Так, например, вышеупомянутый код вернёт промис, разрешающийся с результатом `1`. Проверим это:

```js run
async function f() {
  return 1;
}

f().then(alert); // 1
```

...Мы могли вернуть промис и явным образом, что было бы равносильно:

```js run
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

В общем, `async` делает так, что функция всегда возвращает промис (если возвращается обычное значение, то оно оборачивается в промис). Просто, не так ли? Но есть и другое ключевое слово — `await` — оно работает только внутри `async`-функций. И оно просто шикарно!

## Await

Синтаксис:

```js
// работает только внутри async-функций
let value = await promise;
```

Ключевое слово `await` заставляет JavaScript ждать, пока промис завершится с каким-либо результатом.

Пример промиса, разрешающегося через 1 секунду:
```js run
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

*!*
  let result = await promise; // ждёт разрешения промиса (*)
*/!*

  alert(result); // "готово!"
}

f();
```

Выполнение функции приостанавливается на строке `(*)`, затем продолжается, когда промис разрешается. При этом `result` принимает значение результата. Таким образом, наш код показывает "готово!" спустя одну секунду.

Подчернём, что `await` действительно делает так, что JavaScript ждёт разрешения промиса, а потом продолжает, используя его результат. При этом ресурсы процессора не расходуются, поскольку в это время движок может производить другую работу: исполнять другие скрипты, обрабатывать события и т.д.


Это прсто более элегантный способ получения результата промиса, чем `promise.then`. Такой код проще писать и читать.

````warn header="В обычных функциях использовать `await` нельзя"
Если попытаемся использовать `await` в функциях, объявленных без `async`, то получим синтаксическую ошибку:

```js run
function f() {
  let promise = Promise.resolve(1);
*!*
  let result = await promise; // Синтаксическая ошибка
*/!*
}
```

Если забыть поставить `async` перед функцией, то будет такая ошибка. Как уже сказано, `await` работает только внутри `async function`.
````

Возьмём пример `showAvatar()` из главы <info:promise-chaining> и перепишем его, используя `async/await`:

<!-- (TODO: проверить ссылку) -->

1. Во-первых, заменим вызовы `.then` на `await`.
2. Во-вторых, чтобы это заработало, к объявлениям функций добавим `async`.

```js run
async function showAvatar() {

  // читаем наш JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // читаем Github-пользователя
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // показываем аватар
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // ждём 3 секунды
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

Код получился чистым и читабельным, не так ли? Намного лучше предыдущей версии.

````smart header="`await` не работает в глобальной области"
Те, кто только осваивают `await`, обычно забывают о том, что `await` не работает в глобальном коде. Следующий пример не сработает:

```js run
// синтаксическая обшибка в глобальной области
let response = await fetch('/article/promise-chaining/user.json');
let user = await response.json();
```

Для таких случаев нужно обернуть код, использующий `await` в `async`-функцию. Как в вышеупомянутом примере.
````
````smart header="`await` принимает thenable"
Как и `promise.then`, `await` может работать с thenable-объектами (это объекты, у которых можно вызвать метод `then`). Это сделано для поддержки сторонних объектов, не являющихся промисами, но совместимых с ними: если у обьекта можно вызвать `.then()`, значит его можно использовать с `await`.

<!-- TODO: уточнить перевод thenable -->

Например, здесь `await` принимает `new Thenable(1)`:
```js run
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // разрешится значением this.num*2 через 1000мс
    setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
};

async function f() {
  // ждёт 1 секунду, затем result принимает значение 2
  let result = await new Thenable(1);
  alert(result);
}

f();
```

Если `await` получает объект, не являющийся промисом, но имеющий метод `.then`, то он вызвывает этот метож, прередавая ему аргументы `resolve` и `reject`. Затем он ждёт, пока один из этих методов будет вызван (в нашем примере вызов происходит в строке `(*)`), затем продолжает исполнение кода с полученным результатом.
````

````smart header="Async-методы"
Метод класса тоже может быть асинхронным. Просто добавьте перед ним `async`.

Например:

```js run
class Waiter {
*!*
  async wait() {
*/!*
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1
```
Смысл тот же: гарантировать, что возвращаемое значение будет промисом и позволить использование `await`.

````
## Обработка ошибок

Если промис разрешается нормально (resolve), то `await promise` возвращает результат. Но если срабатывает ошибка (reject), то `await` выбрасывает исключение, как это сделала бы конструкция `throw`.

Данный код:

```js
async function f() {
*!*
  await Promise.reject(new Error("Опаньки!"));
*/!*
}
```

...Аналогичен следующему:

```js
async function f() {
*!*
  throw new Error("Опаньки!");
*/!*
}
```

В реальной жизни может пройти какое-то время, прежде, чем промис завершится с ошибкой. В таком случае `await` будет ожидать, а затем выбросит исключение.

Исключение можно перехватить с помощью `try..catch`, точно так же, как и в случае обычного `throw`:

```js run
async function f() {

  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
*!*
    alert(err); // TypeError: failed to fetch
*/!*
  }
}

f();
```

В случае ошибки, управление передаётся блоку `catch`. В `try` можно обернуть и несколько строк:

```js run
async function f() {

  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // перехватывает исключения как в fetch, так и в response.json
    alert(err);
  }
}

f();
```

Если у нас нет `try..catch`, то промис, сгенерированный асинхронной функцией `f()`, завершается с ошибкой. Чтобы обработать её, можно воспользоваться `.catch`:

```js run
async function f() {
  let response = await fetch('http://no-such-url');
}

// f() возвращает промис, который впоследствии завершается с ошибкой:
*!*
f().catch(alert); // TypeError: failed to fetch // (*)
*/!*
```

Если забыть здесь добавить `.catch`, то получим необработанную ошибку промиса (её можно увидеть в консоли). Можно перехватывать подобные ошибки в глобальном обработчике ошибок, как описано в главе <info:promise-chaining>.

<!-- TODO: проверить ссылку -->

```smart header="`async/await` и `promise.then/catch`"
Как правило, при использовании `async/await`, `.then` не используется, поскольку `await` сам ждёт завершения промиса. Также вместо `.catch` мы используем простую конструкцию `try..catch`. И обычно так удобнее.

<!-- TODO: детавтологизировать -->

Но в глобальной области кода, когда мы находимся вне какой бы то ни было `async`-функции, синтаксис не позволяет использовать `await`, поэтому нормальной практикой считается пользоваться `.then/catch` для получения конечного результата (или для финальной обработки ошибки).

Как, например, в строке `(*)` из предыдущего примера.
```

````smart header="`async/await` хорошо рабоатет с `Promise.all`"
Когда нужно дождаться нескольких промисов, можно завернуть их в `Promise.all` и использовать `await`:

```js
// ждём массив результатов
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);
```

Ошибка, в случае возникновения, распространяется, как обычно: от упавшего промиса к `Promise.all` — и далее она превращается в исключение, которое можно перехватить с помощью `try..catch`, обёрнутого вокруг вызова.

````

## Итого

Ключевое слово `async` перед функцией служит двум целям:

1. Заставить функцию всегда возвращать промис.
2. Позволяет использовать `await`.

Ключевое слово `await` перед промисом действует так, что JavaScript ожидает завершения промиса, а затем:

1. Если есть ошибка, генерируется исключение, как если бы в этом месте было вызвано `throw error`.
2. Иначе, возвращается результат, который можно присвоить переменной или использовать в выражении.

Вместе эти два ключевых слова создают замечательный фреймворк, позволяющий писать хорошо читаемый и поддерживаемый асинхронный код.

Нам редко нужно использовать `promise.then/catch` с `async/await`, но не стоит забывать, что данный подход основан на промисах, поэтому иногда (чаще всего, в глобальной области) нам приходится использовать эти методы. Также, `Promise.all()` — это хороший способ дождаться завершения нескольких одновременных задач.